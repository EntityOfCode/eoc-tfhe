"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SolanaToken = exports.SOLToTokenAmount = exports.lamportToTokenAmount = void 0;
/**
 * Copyright (C) 2022-2023 Permanent Data Solutions, Inc. All Rights Reserved.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
const web3_js_1 = require("@solana/web3.js");
const bignumber_js_1 = require("bignumber.js");
const bs58_1 = __importDefault(require("bs58"));
const common_js_1 = require("../../utils/common.js");
const logger_js_1 = require("../logger.js");
const lamportToTokenAmount = (winston) => winston;
exports.lamportToTokenAmount = lamportToTokenAmount;
const SOLToTokenAmount = (sol) => new bignumber_js_1.BigNumber(sol).times(1e9).valueOf();
exports.SOLToTokenAmount = SOLToTokenAmount;
class SolanaToken {
    constructor({ logger = new logger_js_1.TurboWinstonLogger(), gatewayUrl = 'https://api.mainnet-beta.solana.com', pollingOptions = {
        maxAttempts: 10,
        pollingIntervalMs: 5000,
        initialBackoffMs: 7000,
    }, } = {}) {
        this.logger = logger;
        this.gatewayUrl = gatewayUrl;
        this.connection = new web3_js_1.Connection(gatewayUrl, 'confirmed');
        this.pollingOptions = pollingOptions;
    }
    async createAndSubmitTx({ target, tokenAmount, signer, }) {
        const publicKey = new web3_js_1.PublicKey(bs58_1.default.encode(await signer.getPublicKey()));
        const tx = new web3_js_1.Transaction({
            feePayer: publicKey,
            ...(await this.connection.getLatestBlockhash()),
        });
        tx.add(web3_js_1.SystemProgram.transfer({
            fromPubkey: publicKey,
            toPubkey: new web3_js_1.PublicKey(target),
            lamports: +new bignumber_js_1.BigNumber(tokenAmount),
        }));
        const serializedTx = tx.serializeMessage();
        const signature = await signer.signData(serializedTx);
        tx.addSignature(publicKey, Buffer.from(signature));
        const id = bs58_1.default.encode(signature);
        await this.submitTx(tx, id);
        return { id, target };
    }
    async submitTx(tx, id) {
        this.logger.debug('Submitting fund transaction...', { id });
        await this.connection.sendRawTransaction(tx.serialize(), {
            maxRetries: this.pollingOptions.maxAttempts,
        });
        if (tx.recentBlockhash === undefined ||
            tx.lastValidBlockHeight === undefined) {
            throw new Error('Failed to submit Transaction --  missing blockhash or lastValidBlockHeight from transaction creation. Solana Gateway Url:' +
                this.gatewayUrl);
        }
        await this.connection.confirmTransaction({
            signature: id,
            blockhash: tx.recentBlockhash,
            lastValidBlockHeight: tx.lastValidBlockHeight,
        }, 'finalized');
    }
    async pollForTxBeingAvailable({ txId, }) {
        const { maxAttempts, pollingIntervalMs, initialBackoffMs } = this.pollingOptions;
        this.logger.debug('Polling for transaction...', {
            txId,
            pollingOptions: this.pollingOptions,
        });
        await (0, common_js_1.sleep)(initialBackoffMs);
        let attempts = 0;
        while (attempts < maxAttempts) {
            let status = undefined;
            attempts++;
            try {
                status = await this.connection.getSignatureStatus(txId);
            }
            catch (err) {
                // Continue retries when request errors
                this.logger.debug('Failed to poll for transaction...', { err });
            }
            if (status && status.value && status.value.err !== null) {
                throw new Error(`Transaction failed: ${status.value.err}`);
            }
            if (status && status.value && status.value.slot !== null) {
                return;
            }
            this.logger.debug('Transaction not found, polling...', {
                txId,
                attempts,
                maxAttempts,
                pollingIntervalMs,
            });
            await (0, common_js_1.sleep)(pollingIntervalMs);
        }
        throw new Error('Transaction not found after polling, transaction id: ' + txId);
    }
}
exports.SolanaToken = SolanaToken;
