/**
 * Copyright (C) 2022-2023 Permanent Data Solutions, Inc. All Rights Reserved.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
import { BigNumber } from 'bignumber.js';
import { TurboHTTPService } from './http.js';
import { TurboWinstonLogger } from './logger.js';
export const developmentPaymentServiceURL = 'https://payment.ardrive.dev';
export const defaultPaymentServiceURL = 'https://payment.ardrive.io';
export class TurboUnauthenticatedPaymentService {
    constructor({ url = defaultPaymentServiceURL, retryConfig, logger = new TurboWinstonLogger(), token = 'arweave', }) {
        this.logger = logger;
        this.httpService = new TurboHTTPService({
            url: `${url}/v1`,
            retryConfig,
            logger: this.logger,
        });
        this.token = token;
    }
    getFiatRates() {
        return this.httpService.get({
            endpoint: '/rates',
        });
    }
    getFiatToAR({ currency, }) {
        return this.httpService.get({
            endpoint: `/rates/${currency}`,
        });
    }
    getSupportedCountries() {
        return this.httpService.get({
            endpoint: '/countries',
        });
    }
    getSupportedCurrencies() {
        return this.httpService.get({
            endpoint: '/currencies',
        });
    }
    async getUploadCosts({ bytes, }) {
        const fetchPricePromises = bytes.map((byteCount) => this.httpService.get({
            endpoint: `/price/bytes/${byteCount}`,
        }));
        const wincCostsForBytes = await Promise.all(fetchPricePromises);
        return wincCostsForBytes;
    }
    getWincForFiat({ amount, }) {
        const { amount: paymentAmount, type: currencyType } = amount;
        return this.httpService.get({
            endpoint: `/price/${currencyType}/${paymentAmount}`,
        });
    }
    appendPromoCodesToQuery(promoCodes) {
        const promoCodesQuery = promoCodes.join(',');
        return promoCodesQuery ? `promoCode=${promoCodesQuery}` : '';
    }
    async getCheckout({ amount, owner, promoCodes = [], uiMode = 'hosted', }, headers) {
        const { amount: paymentAmount, type: currencyType } = amount;
        const endpoint = `/top-up/checkout-session/${owner}/${currencyType}/${paymentAmount}?uiMode=${uiMode}${promoCodes.length > 0
            ? `&${this.appendPromoCodesToQuery(promoCodes)}`
            : ''}&token=${this.token}`;
        const { adjustments, paymentSession, topUpQuote } = await this.httpService.get({
            endpoint,
            headers,
        });
        return {
            winc: topUpQuote.winstonCreditAmount,
            adjustments,
            url: paymentSession.url ?? undefined,
            id: paymentSession.id,
            client_secret: paymentSession.client_secret ?? undefined,
            paymentAmount: topUpQuote.paymentAmount,
            quotedPaymentAmount: topUpQuote.quotedPaymentAmount,
        };
    }
    createCheckoutSession(params) {
        return this.getCheckout(params);
    }
    async submitFundTransaction({ txId, }) {
        const response = await this.httpService.post({
            endpoint: `/account/balance/${this.token}`,
            data: Buffer.from(JSON.stringify({ tx_id: txId })),
        });
        if ('creditedTransaction' in response) {
            return {
                id: response.creditedTransaction.transactionId,
                quantity: response.creditedTransaction.transactionQuantity,
                owner: response.creditedTransaction.destinationAddress,
                winc: response.creditedTransaction.winstonCreditAmount,
                token: response.creditedTransaction.tokenType,
                status: 'confirmed',
                block: response.creditedTransaction.blockHeight,
            };
        }
        else if ('pendingTransaction' in response) {
            return {
                id: response.pendingTransaction.transactionId,
                quantity: response.pendingTransaction.transactionQuantity,
                owner: response.pendingTransaction.destinationAddress,
                winc: response.pendingTransaction.winstonCreditAmount,
                token: response.pendingTransaction.tokenType,
                status: 'pending',
            };
        }
        else if ('failedTransaction' in response) {
            return {
                id: response.failedTransaction.transactionId,
                quantity: response.failedTransaction.transactionQuantity,
                owner: response.failedTransaction.destinationAddress,
                winc: response.failedTransaction.winstonCreditAmount,
                token: response.failedTransaction.tokenType,
                status: 'failed',
            };
        }
        throw new Error('Unknown response from payment service: ' + response);
    }
}
// NOTE: to avoid redundancy, we use inheritance here - but generally prefer composition over inheritance
export class TurboAuthenticatedPaymentService extends TurboUnauthenticatedPaymentService {
    constructor({ url = defaultPaymentServiceURL, retryConfig, signer, logger = new TurboWinstonLogger(), token = 'arweave', tokenTools, }) {
        super({ url, retryConfig, logger, token });
        this.signer = signer;
        this.tokenTools = tokenTools;
    }
    async getBalance() {
        const headers = await this.signer.generateSignedRequestHeaders();
        const balance = await this.httpService.get({
            endpoint: '/balance',
            headers,
            allowedStatuses: [200, 404],
        });
        // 404's don't return a balance, so default to 0
        return balance.winc ? balance : { winc: '0' };
    }
    async getWincForFiat({ amount, promoCodes = [], }) {
        return this.httpService.get({
            endpoint: `/price/${amount.type}/${amount.amount}?${this.appendPromoCodesToQuery(promoCodes)}`,
            headers: await this.signer.generateSignedRequestHeaders(),
        });
    }
    async createCheckoutSession(params) {
        return this.getCheckout(params, await this.signer.generateSignedRequestHeaders());
    }
    async getTargetWalletForFund() {
        const { addresses } = await this.httpService.get({
            endpoint: '/info',
        });
        const walletAddress = addresses[this.token];
        if (!walletAddress) {
            throw new Error(`No wallet address found for token type: ${this.token}`);
        }
        return walletAddress;
    }
    async topUpWithTokens({ feeMultiplier = 1, tokenAmount: tokenAmountV, }) {
        if (!this.tokenTools) {
            throw new Error(`Token type not supported for crypto fund ${this.token}`);
        }
        const tokenAmount = new BigNumber(tokenAmountV);
        const target = await this.getTargetWalletForFund();
        this.logger.debug('Funding account...', {
            feeMultiplier,
            tokenAmount,
            target,
        });
        const fundTx = await this.tokenTools.createAndSubmitTx({
            target,
            tokenAmount,
            feeMultiplier,
            signer: this.signer,
        });
        const txId = fundTx.id;
        try {
            // Let transaction settle some time
            await this.tokenTools.pollForTxBeingAvailable({ txId });
        }
        catch (e) {
            this.logger.error(`Failed to poll for transaction being available from ${this.token} gateway... Attempting to submit fund tx to Turbo...`, e);
        }
        try {
            return {
                ...(await this.submitFundTransaction({ txId })),
                target: fundTx.target,
                reward: fundTx.reward,
            };
        }
        catch (e) {
            this.logger.debug('Failed to submit fund transaction...', e);
            throw Error(`Failed to submit fund transaction! Save this Transaction ID and try again with 'turbo.submitFundTransaction(id)': ${txId}`);
        }
    }
}
